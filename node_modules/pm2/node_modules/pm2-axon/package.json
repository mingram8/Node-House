{
  "name": "pm2-axon",
  "description": "High-level messaging & socket patterns implemented in pure js",
  "version": "3.0.2",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "dependencies": {
    "debug": "~2.2.0",
    "escape-regexp": "0.0.1",
    "amp-message": "~0.1.1",
    "amp": "~0.3.1"
  },
  "devDependencies": {
    "better-assert": "*",
    "should": "*",
    "mocha": "*",
    "commander": "*",
    "humanize-number": "0.0.1"
  },
  "keywords": [
    "zmq",
    "zeromq",
    "pubsub",
    "socket",
    "emitter",
    "ipc",
    "rpc"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/visionmedia/axon.git"
  },
  "scripts": {
    "test": "make test"
  },
  "license": "MIT",
  "readme": "# Axon\n\n  Axon is a message-oriented socket library for node.js heavily inspired by zeromq. For a light-weight\n  UDP alternative you may be interested in [punt](https://github.com/visionmedia/punt).\n\n[![Build Status](https://travis-ci.org/unitech/pm2-axon.png)](https://travis-ci.org/unitech/pm2-axon)\n\n## Installation\n\n    $ npm install axon\n\n## Features\n\n  - message oriented\n  - automated reconnection\n  - light-weight wire protocol\n  - mixed-type arguments (strings, objects, buffers, etc)\n  - unix domain socket support\n  - fast (~800 mb/s ~500,000 messages/s)\n\n## Events\n\n  - `close` when server or connection is closed\n  - `error` (err) when an un-handled socket error occurs\n  - `ignored error` (err) when an axon-handled socket error occurs, but is ignored\n  - `socket error` (err) emitted regardless of handling, for logging purposes\n  - `reconnect attempt` when a reconnection attempt is made\n  - `connect` when connected to the peer, or a peer connection is accepted\n  - `disconnect` when an accepted peer disconnects\n  - `bind` when the server is bound\n  - `drop` (msg) when a message is dropped due to the HWM\n  - `flush` (msgs) queued when messages are flushed on connection\n\n## Patterns\n\n  - push / pull\n  - pub / sub\n  - req / rep\n  - pub-emitter / sub-emitter\n\n## Mixed argument types\n\n  Backed by [node-amp-message](https://github.com/visionmedia/node-amp-message)\n  you may pass strings, objects, and buffers as arguments.\n\n```js\npush.send('image', { w: 100, h: 200 }, imageBuffer);\npull.on('message', function(type, size, img){});\n```\n\n## Push / Pull\n\n`PushSocket`s distribute messages round-robin:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('push');\n\nsock.bind(3000);\nconsole.log('push server started');\n\nsetInterval(function(){\n  sock.send('hello');\n}, 150);\n```\n\nReceiver of `PushSocket` messages:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('pull');\n\nsock.connect(3000);\n\nsock.on('message', function(msg){\n  console.log(msg.toString());\n});\n```\n\n\nBoth `PushSocket`s and `PullSocket`s may `.bind()` or `.connect()`. In the\nfollowing configuration the push socket is bound and pull \"workers\" connect\nto it to receive work:\n\n![push bind](http://f.cl.ly/items/473u3m1a0k1i0J0I3s04/ss-push.png)\n\nThis configuration shows the inverse, where workers connect to a \"sink\"\nto push results:\n\n![pull bind](http://f.cl.ly/items/3Y0j2v153Q0l1r373i0H/ss-pull.png)\n\n## Pub / Sub\n\n`PubSocket`s send messages to all subscribers without queueing. This is an\nimportant difference when compared to a `PushSocket`, where the delivery of\nmessages will be queued during disconnects and sent again upon the next connection.\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('pub');\n\nsock.bind(3000);\nconsole.log('pub server started');\n\nsetInterval(function(){\n  sock.send('hello');\n}, 500);\n```\n\n`SubSocket` simply receives any messages from a `PubSocket`:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('sub');\n\nsock.connect(3000);\n\nsock.on('message', function(msg){\n  console.log(msg.toString());\n});\n```\n\n `SubSocket`s may optionally `.subscribe()` to one or more \"topics\" (the first multipart value),\n using string patterns or regular expressions:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('sub');\n\nsock.connect(3000);\nsock.subscribe('user:login');\nsock.subscribe('upload:*:progress');\n\nsock.on('message', function(topic, msg){\n\n});\n```\n\n## Req / Rep\n\n`ReqSocket` is similar to a `PushSocket` in that it round-robins messages\nto connected `RepSocket`s, however it differs in that this communication is\nbi-directional, every `req.send()` _must_ provide a callback which is invoked\nwhen the `RepSocket` replies.\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('req');\n\nsock.bind(3000);\n\nsock.send(img, function(res){\n\n});\n```\n\n`RepSocket`s receive a `reply` callback that is used to respond to the request,\nyou may have several of these nodes.\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('rep');\n\nsock.connect(3000);\n\nsock.on('message', function(img, reply){\n  // resize the image\n  reply(img);\n});\n```\n\n Like other sockets you may provide multiple arguments or an array of arguments,\n followed by the callbacks. For example here we provide a task name of \"resize\"\n to facilitate multiple tasks over a single socket:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('req');\n\nsock.bind(3000);\n\nsock.send('resize', img, function(res){\n\n});\n```\n\n Respond to the \"resize\" task:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('rep');\n\nsock.connect(3000);\n\nsock.on('message', function(task, img, reply){\n  switch (task) {\n    case 'resize':\n      // resize the image\n      reply(img);\n      break;\n  }\n});\n```\n\n## PubEmitter / SubEmitter\n\n  `PubEmitter` and `SubEmitter` are higher-level `Pub` / `Sub` sockets, using the \"json\" codec to behave much like node's `EventEmitter`. When a `SubEmitter`'s `.on()` method is invoked, the event name is `.subscribe()`d for you. Each wildcard (`*`) or regexp capture group is passed to the callback along with regular message arguments.\n\napp.js:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('pub-emitter');\n\nsock.connect(3000);\n\nsetInterval(function(){\n  sock.emit('login', { name: 'tobi' });\n}, 500);\n```\n\nlogger.js:\n\n```js\nvar axon = require('axon');\nvar sock = axon.socket('sub-emitter');\n\nsock.bind(3000);\n\nsock.on('user:login', function(user){\n  console.log('%s signed in', user.name);\n});\n\nsock.on('user:*', function(action, user){\n  console.log('%s %s', user.name, action);\n});\n\nsock.on('*', function(event){\n  console.log(arguments);\n});\n```\n\n## Socket Options\n\nEvery socket has associated options that can be configured via `get/set`.\n\n  - `identity` - the \"name\" of the socket that uniqued identifies it.\n  - `retry timeout` - connection retry timeout in milliseconds [100]\n  - `retry max timeout` - the cap for retry timeout length in milliseconds [5000]\n  - `hwm` - the high water mark threshold for queues [Infinity]\n\n## Binding / Connecting\n\nIn addition to passing a portno, binding to INADDR_ANY by default, you\nmay also specify the hostname via `.bind(port, host)`, another alternative\nis to specify the url much like zmq via `tcp://<hostname>:<portno>`, thus\nthe following are equivalent:\n\n```\nsock.bind(3000)\nsock.bind(3000, '0.0.0.0')\nsock.bind('tcp://0.0.0.0:3000')\n\nsock.connect(3000)\nsock.connect(3000, '0.0.0.0')\nsock.connect('tcp://0.0.0.0:3000')\n```\n\n  You may also use unix domain sockets:\n\n```\nsock.bind('unix:///some/path')\nsock.connect('unix:///some/path')\n```\n\n## Protocol\n\n  Axon 2.x uses the extremely simple [AMP](https://github.com/visionmedia/node-amp) protocol to send messages on the wire. Codecs are no longer required as they were in Axon 1.x.\n\n## Performance\n\nPreliminary benchmarks on my Macbook Pro based on 10 messages\nper tick as a realistic production application would likely have\neven less than this. \"better\" numbers may be acheived with batching\nand a larger messages/tick count however this is not realistic.\n\n  64 byte messages:\n\n```\n\n      min: 47,169 ops/s\n     mean: 465,127 ops/s\n   median: 500,000 ops/s\n    total: 2,325,636 ops in 5s\n  through: 28.39 mb/s\n\n```\n\n  1k messages:\n\n```\n\n      min: 48,076 ops/s\n     mean: 120,253 ops/s\n   median: 121,951 ops/s\n    total: 601,386 ops in 5.001s\n  through: 117.43 mb/s\n\n```\n\n  8k messages:\n\n```\n\n      min: 36,496 ops/s\n     mean: 53,194 ops/s\n   median: 50,505 ops/s\n    total: 266,506 ops in 5.01s\n  through: 405.84 mb/s\n\n````\n\n  32k messages:\n\n```\n\n      min: 12,077 ops/s\n     mean: 14,792 ops/s\n   median: 16,233 ops/s\n    total: 74,186 ops in 5.015s\n  through: 462.28 mb/s\n\n```\n\n## What's it good for?\n\n  Axon are not meant to combat zeromq nor provide feature parity,\n  but provide a nice solution when you don't need the insane\n  nanosecond latency or language interoperability that zeromq provides\n  as axon do not rely on any third-party compiled libraries.\n\n## Running tests\n\n```\n$ npm install\n$ make test\n```\n\n## Authors\n\n  - [visionmedia](http://github.com/visionmedia)\n  - [gjohnson](https://github.com/gjohnson)\n\n## Links\n\n  - [Screencast](https://vimeo.com/45818408)\n  - [Axon RPC](https://github.com/visionmedia/axon-rpc)\n\n## License\n\n  MIT\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/visionmedia/axon/issues"
  },
  "_id": "pm2-axon@3.0.2",
  "dist": {
    "shasum": "2e1ff66030967f809f97fafbca2c24b7ea67a3f6"
  },
  "_from": "https://registry.npmjs.org/pm2-axon/-/pm2-axon-3.0.2.tgz",
  "_resolved": "https://registry.npmjs.org/pm2-axon/-/pm2-axon-3.0.2.tgz"
}
